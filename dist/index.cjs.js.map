{"version":3,"file":"index.cjs.js","sources":["../src/buffer.ts","../src/util/compareKeys.ts","../src/util/escape.ts","../src/util/extend.ts","../src/util/isIdentifier.ts","../src/util/isProxy.ts","../src/util/objectName.ts","../src/util/index.ts","../src/common.ts","../src/formatters/object.ts","../src/formatters/array.ts","../src/formatters/data.ts","../src/formatters/function.ts","../src/formatters/map.ts","../src/formatters/primitives.ts","../src/formatters/ref.ts","../src/formatters/set.ts","../src/formatter.ts","../src/index.ts"],"sourcesContent":["import { Style, StyleProcessor } from './common'\n\nexport type Fragment = Immediate | Deferred\n\n/**\n * Fragment immediately available for formatting.\n */\nexport type Immediate = string | HardBreak | SoftBreak\n\n/**\n * Fragment which has not yet been formatted.\n */\nexport type Deferred = Buffer | (() => Fragment | Fragment[]) | Styled\n\n/**\n * Always break here\n *\n * When present in a {@link Buffer} this fragment forces the buffer (and all its\n * parent buffers) into multi-line rendering.\n *\n * This fragment will be rendered as a single line break (LF), and if `indent`\n * is set to a positive number, an `indent` number of indentation units. What\n * a single indentation unit is is controlled by {@link Options#indent}.\n */\nexport type HardBreak = {\n    break: 'hard',\n    indent?: number,\n}\n\n/**\n * Optionally break here\n *\n * This fragment will be rendered as its property `text` when the {@link Buffer}\n * containing it is rendered in single line, or as a hard break when rendering\n * in multiple lines.\n *\n * @see HardBreak for description how breaks are rendered.\n */\nexport type SoftBreak = {\n    break: 'soft',\n    text: string,\n    indent?: number,\n}\n\n/**\n * Fragment with styles applied\n */\nexport type Styled = {\n    style: Style,\n    value: Fragment | Fragment[],\n}\n\n/**\n * Formatting options\n */\nexport type Options = {\n    /**\n     * How deeply nested is this buffer?\n     */\n    depth: number,\n    /**\n     * Value used to render indentation.\n     */\n    indent: string,\n    /**\n     * Maximum complexity allowed before formatting over multiple lines.\n     *\n     * Complexity of a buffer is measured by adding complexities of its\n     * component buffers. Each buffer has complexity of at least one.\n     */\n    maxComplexity?: number\n    /**\n     * Style processor\n     */\n    style: StyleProcessor,\n}\n\n/**\n * Result of flushing a {@link Buffer}.\n */\nexport type Result = {\n    /**\n     * Result of formatting this buffer.\n     */\n    value: string\n    /**\n     * How complex is this buffer.\n     */\n    complexity: number\n    /**\n     * Was this buffer formatted over multiple lines?\n     */\n    multiline: boolean\n}\n\n/**\n * Buffers hold intermediate results of formatting.\n *\n * A buffer contains not a formatted string itself, but rather all information\n * required to construct said string. This allows a single buffer to output it's\n * contents in multiple ways depending on context.\n *\n * Contents of a buffer are represented by a sequence of fragments. When\n * building a formatted strings those fragments are concatenated. Some fragments\n * may have multiple representations, from which one is selected based on\n * context and parameters. For list of all possible fragments and their\n * description {@see Fragment}.\n *\n * Buffers may be nested. Nested buffers will be formatted independently, but\n * may of affect formatting of their parent buffer.\n */\nexport default class Buffer {\n    private fragments: Fragment[]\n\n    constructor() {\n        this.fragments = []\n    }\n\n    /**\n     * Flush this buffer\n     */\n    flush(options: Options): Result {\n        const { depth, indent, maxComplexity, style } = options\n        const result: Result = {\n            value: '',\n            complexity: 0,\n            multiline: false,\n        }\n        const partial: Immediate[] = []\n\n        let nestedBuffers = 0\n\n        const processFragment = (fragment: Fragment | Fragment[]): void => {\n            if (fragment instanceof Array) {\n                fragment.forEach(processFragment)\n                return\n            }\n\n            if (fragment instanceof Buffer) {\n                const {\n                    value, complexity, multiline,\n                } = fragment.flush({ ...options, depth: depth + 1})\n\n                result.complexity += complexity\n                result.multiline = result.multiline || multiline\n\n                fragment = value\n                nestedBuffers += 1\n            } else if (typeof fragment === 'function') {\n                return processFragment(fragment())\n            } else if (typeof fragment === 'string') {\n            } else if ('style' in fragment) {\n                const [before, after] = style(fragment.style)\n                partial.push(before)\n                processFragment(fragment.value)\n                partial.push(after)\n                return\n            } else if (fragment.break === 'hard') {\n                result.multiline = true\n            }\n\n            partial.push(fragment)\n        }\n\n        processFragment(this.fragments)\n\n        if (maxComplexity != null && result.complexity >= maxComplexity) {\n            result.multiline = true\n        }\n\n        for (const fragment of partial) {\n            if (typeof fragment === 'string') {\n                result.value += fragment\n                continue\n            }\n\n            if (result.multiline) {\n                result.value += '\\n' + indent.repeat(fragment.indent ?? 0)\n            } else if (fragment.break === 'soft') {\n                result.value += fragment.text\n            }\n        }\n\n        result.complexity += 1\n        return result\n    }\n\n    /**\n     * Push a fragment at the end of this buffer.\n     */\n    push(fragment: Fragment): void {\n        this.fragments.push(fragment)\n    }\n}\n","/**\n * Compare two object keys.\n *\n * This function will sort number first, then strings, both according to their\n * natural order, then unkeyed symbols, in random order, and finally keyed\n * symbols, in natural order of their keys.\n */\nexport default function compareKeys(\n    a: string | number | symbol,\n    b: string | number | symbol,\n): number {\n    if (typeof a === 'number' && typeof b === 'number') {\n        return b - a\n    }\n\n    if (typeof a === 'string' && typeof b === 'string') {\n        return a < b ? -1 : a > b ? 1 : 0\n    }\n\n    // Sort numbers before anything else\n    if (typeof a === 'number') return -1\n    if (typeof b === 'number') return 1\n\n    // Sort strings before symbols\n    if (typeof a === 'string') return -1\n    if (typeof b === 'string') return 1\n\n    const akey = Symbol.keyFor(a)\n    const bkey = Symbol.keyFor(b)\n\n    // We can't sort if we can't inspect\n    if (akey == null && bkey == null) return 0\n\n    // Sort unkeyed symbols before keyed\n    if (akey == null) return -1\n    if (bkey == null) return 1\n\n    return akey < bkey ? -1 : akey > bkey ? 1 : 0\n}\n","/**\n * Escape a string.\n */\n// TODO: escape non-printables\nexport default function escape(str: string, terminator?: string): string {\n    const r = str.replace(/[\\0\\n\\r\\v\\t\\b\\f]/g, char => {\n        switch (char) {\n        case '\\0':  return '\\\\0'\n        case '\\n':  return '\\\\n'\n        case '\\r':  return '\\\\r'\n        case '\\v':  return '\\\\v'\n        case '\\t':  return '\\\\t'\n        case '\\b':  return '\\\\b'\n        case '\\f':  return '\\\\f'\n        default:    return char\n        }\n    })\n\n    return terminator\n        ? r.replace(RegExp(terminator, 'g'), '\\\\' + terminator)\n        : r\n}\n","interface HasPrototype {\n    prototype: object\n}\n\nexport default function extend(object: HasPrototype, key: PropertyKey, value: unknown) {\n    Reflect.defineProperty(object.prototype, key, { value, writable: true })\n}\n","/**\n * Check whether string is a valid ECMAScript identifier.\n */\nexport default function isIdentifier(name: string): boolean {\n    // TODO: proper check according to ES6: ID_Start ID_Continue*\n    return name.match(/^[a-zA-Z_$][a-zA-Z0-9_$]*$/) !== null\n}\n","declare var require: any\n\nlet isProxy = <T extends object>(o: T): boolean => false\n\ntry {\n    // In node.js it's possible to detect that an object is a proxy.\n    isProxy = require('util').types.isProxy\n} catch {}\n\nlet inspectProxy = (o: unknown): object | undefined => undefined\n\ntry {\n    inspectProxy = require('repr-format-node-util').inspectProxy\n} catch {}\n\nexport { isProxy, inspectProxy }\n","/**\n * Get name of an object\n *\n * Object's name is its constructor's name, optionally followed by tag in square\n * brackets (where tag is value of non-enumerable property\n * {@link Symbol.toStringTag}).\n *\n * If the object has no tag and its constructor is either {@link Object} or\n * {@link Array} `null` is returned instead.\n */\nexport default function objectName<T extends object>(obj: T): string | null {\n    const prototype = Reflect.getPrototypeOf(obj)\n    const constructor = prototype && prototype.constructor\n    const tag = !Reflect.getOwnPropertyDescriptor(obj, Symbol.toStringTag)?.enumerable\n        ? Reflect.get(obj, Symbol.toStringTag) as string\n        : null\n\n    if ((constructor === Object || constructor === Array) && tag == null) return null\n\n    return tag == null\n        ? constructor!!.name\n        : constructor!!.name + ' [' + tag + ']'\n}\n","import compareKeys from './compareKeys'\nimport escape from './escape'\nimport extend from './extend'\nimport isIdentifier from './isIdentifier'\nimport * as isProxy from './isProxy'\nimport objectName from './objectName'\n\nexport default {\n    compareKeys,\n    escape,\n    extend,\n    isIdentifier,\n    ...isProxy,\n    objectName,\n}\n","import Formatter from './formatter'\n\nexport type ReprFunction = (fmt: Formatter) => void\n\n/**\n * If an object has a method with this symbol as it's name, and a signature\n * of {@link ReprFuction}, it will be used to represent that object.\n */\nexport const represent = Symbol.for('@@represent')\n\n/**\n * Name of a colour\n *\n * With exception of `hint` all names in this enumeration correspond to\n * a JavaScript (syntactic) primitive. Those colour will be used directly\n * when formatting primitives. When formatting non-primitives, the colour of\n * closes primitive will be used instead (for example, `Uint8Array` is a byte-\n * _string_, and as such will use the `string` colour).\n *\n * `hint` is a special colour used to format hints (such as reference markers)\n * and values which can't be expressed in JavaScript.\n */\nexport type Style =\n    | 'date'\n    | 'hint'\n    | 'null'\n    | 'number'\n    | 'regexp'\n    | 'string'\n    | 'symbol'\n    | 'undefined'\n\n/**\n * Styling function\n *\n * This function transforms colour names into an _apply string_ and an _unset\n * string_. The _apply string_ will be emitted before contents of {@link Styled}\n * and is responsible for setting the style. The _unset string_ will be emitted\n * after contents and is responsible for resetting styles back to what they\n * were.\n *\n * This function will be called once for each {@link Styled} and is allowed to\n * mutate its context. Due to this a single styling function should only be used\n * in one {@link Formatter}.\n *\n * When implementing this function for terminal it may use ANSI escape codes.\n * When implementing for a browser it may always return `'%c'` and record styles\n * to be later combined with formatted string for {@link console.log}.\n */\nexport type StyleProcessor = (style: Style) => [string, string]\n\nexport interface Representable {\n    [represent]: ReprFunction\n}\n\ndeclare global {\n    interface Array<T> { [represent]: ReprFunction }\n    interface Date { [represent]: ReprFunction }\n    interface Float32Array { [represent]: ReprFunction }\n    interface Float64Array { [represent]: ReprFunction }\n    interface Function { [represent]: ReprFunction }\n    interface Int16Array { [represent]: ReprFunction }\n    interface Int32Array { [represent]: ReprFunction }\n    interface Int8Array { [represent]: ReprFunction }\n    interface Map<K, V> { [represent]: ReprFunction }\n    interface Object { [represent]: ReprFunction }\n    interface RegExp { [represent]: ReprFunction }\n    interface Set<T> { [represent]: ReprFunction }\n    interface String { [represent]: ReprFunction }\n    interface Symbol { [represent]: ReprFunction }\n    interface Uint16Array { [represent]: ReprFunction }\n    interface Uint32Array { [represent]: ReprFunction }\n    interface Uint8Array { [represent]: ReprFunction }\n    interface Uint8ClampedArray { [represent]: ReprFunction }\n    interface WeakMap<K, V> { [represent]: ReprFunction }\n    interface WeakSet<T> { [represent]: ReprFunction }\n}\n","import Formatter, { Struct } from '../formatter'\nimport util from '../util'\nimport { represent } from '../common'\n\nexport function formatObject(this: object, fmt: Formatter) {\n    fmt.struct(this, fmt => {\n        for (const key of Reflect.ownKeys(this).sort(util.compareKeys)) {\n            formatField(fmt, this, key)\n        }\n    })\n}\nutil.extend(Object, represent, formatObject)\n\nexport function formatField(fmt: Struct, obj: object, key: PropertyKey) {\n    try {\n        if (Reflect.getOwnPropertyDescriptor(obj, key)!.enumerable) {\n            fmt.field(key, obj[key as keyof object])\n        }\n    } catch (ex: any) {\n        const value = [ex.name, ' when accessing field']\n\n        if (ex.message.length > 0) {\n            value.push(': ', ex.message)\n        }\n\n        fmt.write_field(key, () => fmt.write({ style: 'hint', value }))\n    }\n}\n","import Formatter from '../formatter'\nimport util from '../util'\nimport { represent } from '../common'\nimport { formatField } from './object'\n\nexport function formatArray(this: Array<unknown>, fmt: Formatter) {\n    fmt.list(this, fmt => {\n        const props = []\n        const symprops = []\n\n        let lastKey = 0\n        // First iterate over all items in this array.\n        // XXX: are they always properly sorted?\n        for (const key of Reflect.ownKeys(this)) {\n            let num\n            try {\n                num = Number(key)\n            } catch (ex) {\n                num = null\n            }\n\n            if (num === null || num !== num) {\n                props.push(key)\n            } else {\n                const dif = num - lastKey - 1\n                if (dif > 0) {\n                    fmt.write_item({\n                        style: 'undefined',\n                        value: dif === 1\n                            ? 'empty item'\n                            :  (dif.toString() + ' empty items')\n                    })\n                }\n                fmt.entry(this[num])\n                lastKey = num\n            }\n        }\n\n        // Then append any remaining unset entries\n        if (lastKey + 1 < this.length) {\n            const dif = this.length - lastKey - 1\n            fmt.write_item({\n                style: 'undefined',\n                value: dif === 1\n                    ? 'empty item'\n                    :  dif.toString() + ' empty items'\n            })\n        }\n\n        // And finally properties\n        for (const prop of props.sort(util.compareKeys)) {\n            formatField(fmt, this, prop)\n        }\n    })\n}\n\ninterface TypedArrayConstructor {\n    readonly prototype: TypedArray\n}\ninterface TypedArray {}\n\nutil.extend(Array, represent, formatArray)\nutil.extend(Reflect.getPrototypeOf(Int8Array) as TypedArrayConstructor, represent, formatArray)\n\nconst HEX = '0123456789abcdef'\n\nexport function formatByteArray(this: Uint8Array, fmt: Formatter) {\n    let value = '\"'\n\n    for (const byte of this) {\n        switch (byte) {\n        case 0:  fmt.write('\\\\0'); continue\n        case 8:  fmt.write('\\\\b'); continue\n        case 9:  fmt.write('\\\\t'); continue\n        case 10: fmt.write('\\\\n'); continue\n        case 11: fmt.write('\\\\v'); continue\n        case 12: fmt.write('\\\\f'); continue\n        case 13: fmt.write('\\\\r'); continue\n        case 34: fmt.write('\\\\\"'); continue\n        }\n\n        if (byte >= 0x20 && byte <= 0x7e) {\n            value += String.fromCharCode(byte)\n        } else {\n            value += '\\\\x' + HEX[Math.floor(byte / 16)] + HEX[byte % 16]\n        }\n    }\n\n    value += '\"'\n\n    fmt.write(util.objectName(this)!, ' ', { style: 'string', value })\n}\nutil.extend(Uint8Array, represent, formatByteArray)\n","import Formatter from '../formatter'\nimport util from '../util'\nimport { represent } from '../common'\n\nexport function formatArrayBuffer(this: ArrayBuffer, fmt: Formatter) {\n    fmt.write(util.objectName(this)!, ' [ ')\n\n    if (this.byteLength === 0) {\n        fmt.write({ style: 'undefined', value: 'empty' })\n    } else if (this.byteLength === 1) {\n        fmt.write({ style: 'hint', value: '1 byte' })\n    } else {\n        fmt.write({ style: 'hint', value: [this.byteLength.toString(), ' bytes'] })\n    }\n\n    fmt.write(' ]')\n}\nutil.extend(ArrayBuffer, represent, formatArrayBuffer)\n\nexport function formatDataView(this: DataView, fmt: Formatter) {\n    const name = util.objectName(this)!\n    const byte_bytes = this.byteLength === 1 ? 'byte' : 'bytes'\n\n    fmt.write(\n        name,\n        ' [ ',\n        {\n            style: 'hint',\n            value: [\n                this.byteLength.toString(),\n                ' ',\n                byte_bytes,\n                ' from ',\n                this.buffer.byteLength.toString(),\n                ', starting at byte ',\n                this.byteOffset.toString(),\n            ],\n        },\n        ' ]',\n    )\n}\nutil.extend(DataView, represent, formatDataView)\n","import Formatter from '../formatter'\nimport util from '../util'\nimport { represent } from '../common'\n\nexport function formatFunction(this: Function, fmt: Formatter) {\n    const value = this.name\n        ? ['<function ', this.name, '>']\n        : '<function>'\n    fmt.write({ style: 'hint', value })\n}\nutil.extend(Function, represent, formatFunction)\n","import Formatter from '../formatter'\nimport util from '../util'\nimport { represent } from '../common'\n\nexport function formatMap(this: Map<unknown, unknown>, fmt: Formatter) {\n    fmt.map(this, fmt => {\n        for (const [key, value] of this) {\n            fmt.entry(key, value)\n        }\n    })\n}\nutil.extend(Map, represent, formatMap)\n\nexport function formatWeakMap(this: WeakMap<object, unknown>, fmt: Formatter) {\n    fmt.write(util.objectName(this)!)\n}\nutil.extend(WeakMap, represent, formatWeakMap)\n","import Formatter from '../formatter'\nimport util from '../util'\nimport { represent } from '../common'\n\nexport function formatDate(this: Date, fmt: Formatter) {\n    fmt.write({ style: 'date', value: 'Date(' + this.toISOString() + ')' })\n}\nutil.extend(Date, represent, formatDate)\n\nexport function formatSymbol(this: symbol, fmt: Formatter) {\n    const key = Symbol.keyFor(this)\n    const value = key != null\n        ? 'Symbol.for(' + util.escape(key) + ')'\n        : this.toString()\n    fmt.write({ style: 'symbol', value })\n}\nutil.extend(Symbol, represent, formatSymbol)\n\nexport function formatString(this: string, fmt: Formatter) {\n    fmt.write({ style: 'string', value: ['\"', util.escape(this, '\"'), '\"'] })\n}\nutil.extend(String, represent, formatString)\n\nexport function formatRegExp(this: RegExp, fmt: Formatter) {\n    fmt.write({ style: 'regexp', value: ['/', this.source, '/', this.flags] })\n}\nutil.extend(RegExp, represent, formatRegExp)\n\nexport function formatNumberWrapper(this: Boolean | Number, fmt: Formatter) {\n    fmt.write({ style: 'number', value: '[' + util.objectName(this)! + ': ' + this.valueOf() + ']' })\n}\nutil.extend(Boolean, represent, formatNumberWrapper)\nutil.extend(Number, represent, formatNumberWrapper)\n\nexport function formatStringWrapper(this: String, fmt: Formatter) {\n    fmt.write({ style: 'string', value: '[String: \"' + util.escape(this.valueOf(), '\"') + '\"]' })\n}\nutil.extend(String, represent, formatStringWrapper)\n\nexport function formatError(this: Error, fmt: Formatter) {\n    fmt.write({ style: 'hint', value: '[' + this.name })\n    if (this.message.length > 0) {\n        fmt.write({ style: 'hint', value: ': ' + this.message })\n    }\n    fmt.write({ style: 'hint', value: ']' })\n}\nutil.extend(Error, represent, formatError)\n","import Formatter from '../formatter'\nimport { Fragment } from '../buffer'\n\nconst REF_NUMBER: WeakMap<Formatter, number> = new WeakMap()\n\nexport type Reference = {\n    source: Fragment,\n    addRef: () => Fragment,\n}\n\nexport function formatReference(fmt: Formatter): Reference {\n    const ref = { count: 0, number: 0 }\n\n    const source = (): Fragment | Fragment[] => {\n        if (ref.count === 0) return []\n\n        const num = REF_NUMBER.get(fmt) ?? 0\n        REF_NUMBER.set(fmt, num + 1)\n\n        ref.number = num\n\n        return [{ style: 'hint', value: '#' + num }, ' = ']\n    }\n\n    const reference = (): Fragment => ({ style: 'hint', value: '#' + ref.number + '#' })\n\n    const addRef = (): Fragment => {\n        ref.count += 1\n        return reference\n    }\n\n    return { source, addRef }\n}\n","import Formatter from '../formatter'\nimport util from '../util'\nimport { represent } from '../common'\n\nexport function formatSet(this: Set<unknown>, fmt: Formatter) {\n    fmt.set(this, fmt => {\n        for (const value of this) {\n            fmt.entry(value)\n        }\n    })\n}\nutil.extend(Set, represent, formatSet)\n\nexport function formatWeakSet(this: WeakSet<object>, fmt: Formatter) {\n    fmt.write(util.objectName(this)!)\n}\nutil.extend(WeakSet, represent, formatWeakSet)\n","import Buffer, { Fragment } from './buffer'\nimport util from './util'\nimport * as formatters from './formatters'\nimport { StyleProcessor, represent } from './common'\n\nexport interface Options {\n    /**\n     * When set, any value nested deeper will be elided from output.\n     */\n    limitDepth?: number\n    /**\n     * When set to false (default) the value will be formatted in a concise\n     * manner in a single line. When set to true the value will be formatted\n     * over multiple lines with indentation, to aid in reading.\n     *\n     * @default true\n     */\n    pretty?: boolean\n    /**\n     * When {@link #pretty} is set to true, use this string for a single level\n     * of indentation.\n     *\n     * @default '  '\n     */\n    indent?: string\n    /**\n     * Current depth. Counts towards {@link #limitDepth}, and as a default\n     * indentation level for {@link #pretty}.\n     *\n     * @default 0\n     */\n    depth?: number\n    /**\n     * Maximum complexity allowed before formatting over multiple lines.\n     *\n     * Complexity of an object is measured by adding complexities of its\n     * fields. Each object has complexity of at least one, non-objects and\n     * objects without fields have complexity of 0.\n     *\n     * @default 3 when {@link #pretty} is `true`, `Infinity` otherwise\n     */\n    maxComplexity?: number\n    /**\n     * Style processor\n     *\n     * @default a function returning empty formatting for each colour\n     */\n    style?: StyleProcessor\n}\n\nexport default class Formatter {\n    static Struct: typeof Struct\n    static List: typeof List\n    static Set: typeof Set\n    static Map: typeof Map\n\n    /**\n     * Buffer storing current (partial) formatted value.\n     */\n    result: Buffer\n    /**\n     * String to use as indentation per single depth level.\n     */\n    indent: string\n    /**\n     * Current indentation depth.\n     */\n    depth: number\n    /**\n     * Maximum depth before we start eliding.\n     */\n    limitDepth: number\n    /**\n     * Maximum complexity allowed before formatting over multiple lines.\n     */\n    maxComplexity: number\n    /**\n     * Style processor\n     */\n    style: StyleProcessor\n\n    /**\n     * Objects already visited during formatting.\n     *\n     * This map is used to detect cycles.\n     */\n    private seen: WeakMap<object, formatters.Reference>\n\n    /**\n     * Value currently being formatted.\n     */\n    private current: null | unknown\n\n    constructor(options: Options = {}) {\n        const {\n            pretty = false, indent = '  ', depth = 0, limitDepth = Infinity,\n            maxComplexity, style = () => ['', ''], ...rest\n        } = options\n\n        if (Reflect.ownKeys(rest).length > 0) {\n            const invalid = Reflect.ownKeys(rest).join(', ')\n            throw new Error('Invalid options to Formatter: ' + invalid)\n        }\n\n        this.result = new Buffer()\n        this.indent = indent\n        this.depth = depth\n        this.limitDepth = limitDepth\n        this.maxComplexity = pretty ? maxComplexity ?? 3 : Infinity\n        this.style = style\n\n        this.seen = new WeakMap()\n        this.current = null\n    }\n\n    toString(): string {\n        return this.result.flush({\n            depth: this.depth,\n            indent: this.indent,\n            maxComplexity: this.maxComplexity,\n            style: this.style,\n        }).value\n    }\n\n    /**\n     * Write representation of a value to the underlying buffer.\n     */\n    format(value: unknown): void {\n        // Special case null, since typeof null === 'object'\n        if (value === null) {\n            return this.write({ style: 'null', value: 'null' })\n        }\n\n        // Detect cycles\n        if (typeof value === 'object') {\n            let ref = this.seen.get(value!)\n\n            if (ref != null) {\n                return this.write(ref.addRef())\n            } else {\n                ref = formatters.formatReference(this)\n                this.seen.set(value!, ref)\n                this.write(ref.source)\n            }\n        }\n\n        // First try using custom formatters, ...\n\n        let proto = null\n        if (typeof value === 'object') {\n            try {\n                proto = Reflect.getPrototypeOf(value!)\n            } catch (ex: any) {\n                const value = [ex.name, ' when formatting']\n\n                if (ex.message.length > 0) {\n                    value.push(': ', ex.message)\n                }\n\n                return this.write({ style: 'hint', value })\n            }\n        }\n\n        if (typeof value === 'object' && util.isProxy(value!)) {\n            this.write({ style: 'hint', value: 'proxy ' })\n\n            const proxiedObject = util.inspectProxy(value)\n            if (proxiedObject != null) {\n                let ref = this.seen.get(proxiedObject)\n\n                if (ref != null) {\n                    return this.write(ref.addRef())\n                } else {\n                    ref = formatters.formatReference(this)\n                    this.seen.set(proxiedObject, ref)\n                    this.write(ref.source)\n                }\n            }\n        }\n\n        this.current = value\n\n        if (proto && represent in proto) {\n            return proto[represent].call(value, this)\n        } else {\n            // ... and fall back to defaults if there's none.\n            this.formatDefault(value)\n        }\n\n        this.current = null\n    }\n\n    /**\n     * Apply default formatting to a value.\n     *\n     * This function is called for values which do not provide custom formatting\n     * (see {@link represent}). You can overwrite it to customise how such\n     * values are displayed.\n     *\n     * @protected\n     *\n     * @example\n     *\n     * class Custom extends Formatter {\n     *     formatDefault(value) {\n     *         if (typeof value !== 'number') return super.formatDefault(value)\n     *         this.write(value % 2 === 0\n     *             ? 'even'\n     *             : value % 2 === 1 ? 'odd' : 'not an integer')\n     *     }\n     * }\n     *\n     * new Custom().format(123).toString() // => \"odd\"\n     * new Custom().format(86).toString() // => \"even\"\n     * new Custom().format(3.14).toString() // => \"not an integer\"\n     */\n    formatDefault(value: NonNullable<unknown>): void {\n        switch (typeof value) {\n        case 'object':      return formatters.formatObject.call(value!, this)\n        case 'function':    return formatters.formatFunction.call(value, this)\n        case 'string':      return formatters.formatString.call(value, this)\n        case 'symbol':      return formatters.formatSymbol.call(value, this)\n        case 'undefined':   return this.write({ style: 'undefined', value: 'undefined' })\n\n        case 'number':\n        case 'boolean':\n            return this.write({ style: 'number', value: value.toString() })\n\n        case 'bigint':\n            return this.write({ style: 'number', value: [value.toString(), 'n'] })\n        }\n    }\n\n    /**\n     * Write some data to the underlying buffer.\n     *\n     * This function is meant for writing arbitrary unformatted strings, mainly\n     * for implementing custom formatters. If all you want is just to write some\n     * value and have it formatted, see {@link #format}. If you do want to\n     * implement a custom formatter, have a look at higher level formatting\n     * functions, such as {@link #struct}.\n     *\n     * @see #struct\n     * @see #list\n     * @see #set\n     * @see #map\n     */\n    write(...data: Fragment[]) {\n        for (const item of data) {\n            this._write(item)\n        }\n    }\n\n    _write(fragment: Fragment): void {\n        if (typeof fragment !== 'string') {\n            return this.result.push(fragment)\n        }\n\n        do {\n            const inx = fragment.indexOf('\\n')\n\n            if (inx === -1) {\n                this.result.push(fragment)\n                fragment = ''\n            } else {\n                this.result.push(fragment.slice(0, inx + 1))\n                fragment = fragment.slice(inx + 1)\n                this.result.push({ break: 'hard', indent: this.depth })\n            }\n        } while (fragment.length > 0)\n    }\n\n    /**\n     * Helper function for formatting structured ({@code Object}-like) objects.\n     *\n     * This function will write name (see below), followed by an opening\n     * delimiter, then content written by callback, and finally a closing\n     * delimiter. If {@link #pretty} is set then additional formatting will also\n     * be applied.\n     *\n     * The name may be a string, in which case it's written literally,\n     * a {@code null} or omitted, in which case it's not written at all, or\n     * an object, in which case it's derived from it's prototype.\n     *\n     * The opening and closing delimiters are, for this function, {@code \"{\"}\n     * and {@code \"}\"}, respectively, but other variants will use other\n     * delimiters. See their documentation for details.\n     *\n     * The parameter to the callback will provide an extended interface compared\n     * to {@link Formatter}, designed to simplify formatting that particular\n     * kind of objects. Additionally if {@link #pretty} is set it will also take\n     * care of formatting.\n     *\n     * @see #list\n     * @see #set\n     * @see #map\n     *\n     * @example\n     *\n     * new Formatter().struct('Name', fmt => {\n     *     fmt.field('foo', 'bar')\n     *     fmt.field('buz', [1,2,3])\n     * }).toString()\n     *\n     * // will result in\n     *\n     * Name { foo: \"bar\", buz: [1, 2, 3] }\n     */\n    struct(name: string | null | object, callback: (fmt: Struct) => void) {\n        this._subformatter(Struct, name, callback)\n    }\n\n    /**\n     * Helper function for formatting sequence-like objects.\n     *\n     * A variation of {@link #struct}. This function will use {@code \"[\"}\n     * and {@code \"]\"} as opening and closing delimiters.\n     *\n     * @see #struct\n     *\n     * @example\n     *\n     * new Formatter().list('Name', fmt => {\n     *     fmt.entry(1)\n     *     fmt.entry(2)\n     *     fmt.entry(3)\n     * }).toString()\n     *\n     * // will result in\n     *\n     * Name [1, 2, 3]\n     */\n    list(name: string | null | object, callback: (fmt: List) => void) {\n        this._subformatter(List, name, callback)\n    }\n\n    /**\n     * Helper function for formatting set-like objects.\n     *\n     * A variation of {@link #struct}.\n     *\n     * @see #struct\n     *\n     * @example\n     *\n     * new Formatter().set('Name', fmt => {\n     *     fmt.entry(1)\n     *     fmt.entry(2)\n     *     fmt.entry(3)\n     * }).toString()\n     *\n     * // will result in\n     *\n     * Name { 1, 2, 3 }\n     */\n    set(name: string | null | object, callback: (fmt: Set) => void) {\n        this._subformatter(Set, name, callback)\n    }\n\n    /**\n     * Helper function for formatting map-like objects.\n     *\n     * A variation of {@link #struct}.\n     *\n     * @see #struct\n     *\n     * @example\n     *\n     * new Formatter().map('Name', fmt => {\n     *     fmt.entry('foo', 1)\n     *     fmt.entry('bar', 'baz')\n     * }).toString()\n     *\n     * // will result in\n     *\n     * Name { \"foo\" => 1, \"bar\" => \"baz\" }\n     */\n    map(name: string | null | object, callback: (fmt: Map) => void) {\n        this._subformatter(Map, name, callback)\n    }\n\n    private _subformatter<F extends SubFormatter>(\n        formatter: { new(fmt: Formatter, name: string | null | object): F },\n        callback: (fmt: F) => void,\n    ): void\n    private _subformatter<F extends SubFormatter>(\n        formatter: { new(fmt: Formatter, name: string | null | object): F },\n        name: string | null | object,\n        callback: (fmt: F) => void,\n    ): void\n\n    private _subformatter<F extends SubFormatter>(\n        Formatter: { new(fmt: Formatter, name: string | null | object): F },\n        name: string | null | object | ((fmt: F) => void),\n        callback?: (fmt: F) => void,\n    ): void {\n        if (typeof name === 'function') {\n            callback = name as ((fmt: F) => void)\n            name = null\n        }\n\n        const buffer = this.result\n        this.result = new Buffer()\n\n        const formatter = new Formatter(this, name)\n        formatter.begin()\n\n        this.depth += 1\n\n        callback!(formatter)\n\n        this.depth -= 1\n\n        formatter.finish()\n\n        buffer.push(this.result)\n        this.result = buffer\n    }\n}\n\n/**\n * Base class for structural formatting helpers.\n *\n * This class takes care of all basic rendering and formatting, so that its\n * subclasses can focus on just content.\n */\nexport class SubFormatter {\n    formatter: Formatter\n    name: string | null\n    open: string\n    close: string\n    has_elements: boolean\n\n    constructor(formatter: Formatter, name: string | null | object) {\n        if (name != null && typeof name === 'object') {\n            name = util.objectName(name)\n        }\n\n        this.formatter = formatter\n        this.name = name\n\n        this.open = '{'\n        this.close = '}'\n\n        this.has_elements = false\n    }\n\n    /**\n     * Write some data to the underlying buffer.\n     *\n     * @see Formatter#write\n     */\n    write(...args: Fragment[]): void {\n        this.formatter.write(...args)\n    }\n\n    /**\n     * Write representation of a value to the underlying buffer.\n     *\n     * @see Formatter#format\n     */\n    format(value: unknown): void {\n        this.formatter.format(value)\n    }\n\n    /**\n     * Write what should be before the main content.\n     */\n    begin(): void {\n        if (this.name) {\n            this.write(this.name, ' ')\n        }\n        this.write(this.open)\n    }\n\n    /**\n     * Write what should be after the main content.\n     */\n    finish(): void {\n        if (this.has_elements) {\n            this.write({ break: 'soft', text: ' ', indent: this.formatter.depth })\n        }\n        this.write(this.close)\n    }\n\n    write_item(cb: () => void): void\n    write_item(item: Fragment, ...args: Fragment[]): void\n\n    /**\n     * Write a single entry.\n     *\n     * This function takes care of writing any content which should go before\n     * or after an entry as well as formatting, when {@link #pretty} is set.\n     * The actual entry content is written by callback.\n     *\n     * When using sub-formatters you should generally avoid calling\n     * {@link #format} and {@link write} outside of a callback to this function.\n     */\n    write_item(cb?: (() => void) | Fragment, ...args: Fragment[]): void {\n        if (this.has_elements) {\n            this.write(',')\n        }\n        this.write({ break: 'soft', text: ' ', indent: this.formatter.depth })\n\n        if (typeof cb === 'function') {\n            cb()\n        } else if (cb) {\n            this.write(cb, ...args)\n        }\n\n        this.has_elements = true\n    }\n}\n\n/**\n * Formatter for structured (Object-like) data.\n */\nexport class Struct extends SubFormatter {\n    /**\n     * Format a single field.\n     */\n    field(name: PropertyKey, value: unknown): void {\n        this.write_field(name, () => this.format(value))\n    }\n\n    /**\n     * Write a single field.\n     */\n    write_field(name: PropertyKey, cb: () => void): void {\n        super.write_item(() => {\n            if (typeof name === 'symbol' || typeof name === 'number') {\n                this.format(name)\n            } else if (util.isIdentifier(name)) {\n                this.write(name)\n            } else {\n                this.format(name)\n            }\n\n            this.write(': ')\n            cb()\n        })\n    }\n}\nFormatter.Struct = Struct\n\n/**\n * Formatter for sequences.\n *\n * This class extends {@link Struct} because arrays in JavaScript can actually\n * contain non-numeric properties, and thus we need {@link #field} to format\n * them.\n */\nexport class List extends Struct {\n    constructor(...args: ConstructorParameters<typeof Struct>) {\n        super(...args)\n\n        this.open = '['\n        this.close = ']'\n    }\n\n    /**\n     * Write a single entry in this sequence.\n     */\n    entry(value: unknown): void {\n        super.write_item(() => this.format(value))\n    }\n}\nFormatter.List = List\n\n/**\n * Formatter for sets.\n *\n * This differs from {@link List} in that it uses {@code \"{\"} and {@code \"}\"} as\n * delimiters, and only supports entries; there's no equivalent\n * of {@link List#field} for sets.\n */\nexport class Set extends SubFormatter {\n    /**\n     * Write a single entry in this set.\n     */\n    entry(value: unknown): void {\n        super.write_item(() => this.format(value))\n    }\n}\nFormatter.Set = Set\n\n/**\n * Formatter for maps.\n *\n * This is similar to {@link Struct}, except that it uses {@code \"=>\"}\n * as key-value separator, allows any object as key, not just strings and\n * symbols, and that it formats its string keys.\n */\nexport class Map extends SubFormatter {\n    /**\n     * Write a single entry in this map.\n     */\n    entry(key: unknown, value: unknown): void {\n        this.write_item(() => {\n            this.format(key)\n            this.write(' => ')\n            this.format(value)\n        })\n    }\n}\nFormatter.Map = Map\n","import Formatter, { Options } from './formatter'\nimport { represent } from './common'\n\nexport { Style } from './common'\n\n/**\n * Format a value.\n */\nexport default function format(value: unknown, formatterOrOptions?: Formatter | Options): string {\n    let options = {}\n    let formatter = null\n\n    if (formatterOrOptions) {\n        if (formatterOrOptions instanceof Formatter) {\n            formatter = formatterOrOptions\n        } else {\n            options = formatterOrOptions\n        }\n    }\n\n    if (!formatter) {\n        formatter = new Formatter(options)\n    }\n\n    formatter.format(value)\n\n    return formatter.toString()\n}\n\nformat.Formatter = Formatter\nformat.represent = represent\n"],"names":["isProxy","formatters.formatReference","formatters.formatObject","formatters.formatFunction","formatters.formatString","formatters.formatSymbol","Set","Map"],"mappings":"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"}